# Improved workflow that builds, tests and then pushes the OpenHands docker images to the ghcr.io repository
# Key improvements:
# 1. Uses native ARM64 runners to avoid QEMU performance issues
# 2. Dynamic organization name support for forks
# 3. Proper openhands- prefixed image names
# 4. Better caching and parallelization

name: Docker (Improved)

on:
  push:
    branches:
      - main
    tags:
      - '*'
  pull_request:
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual trigger'
        required: true
        default: ''

concurrency:
  group: ${{ github.workflow }}-${{ (github.head_ref && github.ref) || github.run_id }}
  cancel-in-progress: true

env:
  RELEVANT_SHA: ${{ github.event.pull_request.head.sha || github.sha }}

jobs:
  define-matrix:
    runs-on: ubuntu-latest
    outputs:
      base_image: ${{ steps.define-base-images.outputs.base_image }}
      platforms: ${{ steps.define-platforms.outputs.platforms }}
    steps:
      - name: Define base images
        shell: bash
        id: define-base-images
        run: |
          # Only build nikolaik on PRs, otherwise build both nikolaik and ubuntu.
          if [[ "$GITHUB_EVENT_NAME" == "pull_request" ]]; then
            json=$(jq -n -c '[
                { image: "nikolaik/python-nodejs:python3.12-nodejs22", tag: "nikolaik" }
              ]')
          else
            json=$(jq -n -c '[
                { image: "nikolaik/python-nodejs:python3.12-nodejs22", tag: "nikolaik" },
                { image: "ubuntu:24.04", tag: "ubuntu" }
              ]')
          fi
          echo "base_image=$json" >> "$GITHUB_OUTPUT"

      - name: Define build platforms
        id: define-platforms
        run: |
          echo "platforms=[\"linux/amd64\", \"linux/arm64\"]" >> "$GITHUB_OUTPUT"

  # Build app images with native runners for each platform
  build_app_images:
    name: Build App Image (${{ matrix.platform }})
    runs-on: ${{ matrix.platform == 'linux/arm64' && 'ubuntu-latest-arm' || 'ubuntu-latest' }}
    permissions:
      contents: read
      packages: write
    needs: define-matrix
    strategy:
      matrix:
        platform: ${{ fromJson(needs.define-matrix.outputs.platforms) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set repository owner
        run: |
          echo REPO_OWNER=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]') >> $GITHUB_ENV

      - name: Extract platform arch
        id: platform
        run: |
          echo "arch=$(echo ${{ matrix.platform }} | cut -d'/' -f2)" >> $GITHUB_OUTPUT

      - name: Build and push app image
        if: "!github.event.pull_request.head.repo.fork"
        run: |
          # Build single-platform image with native runner
          ./containers/build.sh -i openhands -o ${{ env.REPO_OWNER }} --push --platform ${{ matrix.platform }}

      - name: Build app image for fork
        if: "github.event.pull_request.head.repo.fork"
        run: |
          ./containers/build.sh -i openhands -o ${{ env.REPO_OWNER }} --load --platform ${{ matrix.platform }}

  # Build runtime images with native runners for each platform
  build_runtime_images:
    name: Build Runtime Image (${{ matrix.base_image.tag }}, ${{ matrix.platform }})
    runs-on: ${{ matrix.platform == 'linux/arm64' && 'ubuntu-latest-arm' || 'ubuntu-latest' }}
    permissions:
      contents: read
      packages: write
    needs: define-matrix
    strategy:
      matrix:
        base_image: ${{ fromJson(needs.define-matrix.outputs.base_image) }}
        platform: ${{ fromJson(needs.define-matrix.outputs.platforms) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Cache Poetry dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pypoetry
            ~/.virtualenvs
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-

      - name: Install poetry via pipx
        run: pipx install poetry

      - name: Install Python dependencies using Poetry
        run: make install-python-dependencies POETRY_GROUP=main INSTALL_PLAYWRIGHT=0

      - name: Create source distribution and Dockerfile
        run: poetry run python3 openhands/runtime/utils/runtime_build.py --base_image ${{ matrix.base_image.image }} --build_folder containers/runtime --force_rebuild

      - name: Set repository owner
        run: |
          echo REPO_OWNER=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]') >> $GITHUB_ENV

      - name: Build and push runtime image
        if: "!github.event.pull_request.head.repo.fork"
        run: |
          ./containers/build.sh -i runtime -o ${{ env.REPO_OWNER }} -t ${{ matrix.base_image.tag }} --push --platform ${{ matrix.platform }}

      - name: Build runtime image for fork
        if: "github.event.pull_request.head.repo.fork"
        run: |
          ./containers/build.sh -i runtime -o ${{ env.REPO_OWNER }} -t ${{ matrix.base_image.tag }} --load --platform ${{ matrix.platform }}

  # Merge multi-platform manifests
  create_manifests:
    name: Create Multi-Platform Manifests
    runs-on: ubuntu-latest
    needs: [build_app_images, build_runtime_images, define-matrix]
    if: "!github.event.pull_request.head.repo.fork"
    permissions:
      contents: read
      packages: write
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set repository owner
        run: |
          echo REPO_OWNER=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]') >> $GITHUB_ENV

      - name: Create multi-platform app manifest
        run: |
          docker manifest create ghcr.io/${{ env.REPO_OWNER }}/openhands-app:${{ env.RELEVANT_SHA }} \
            ghcr.io/${{ env.REPO_OWNER }}/openhands-app:${{ env.RELEVANT_SHA }}-amd64 \
            ghcr.io/${{ env.REPO_OWNER }}/openhands-app:${{ env.RELEVANT_SHA }}-arm64
          docker manifest push ghcr.io/${{ env.REPO_OWNER }}/openhands-app:${{ env.RELEVANT_SHA }}

      - name: Create multi-platform runtime manifests
        run: |
          # Create manifests for each base image
          for base_tag in $(echo '${{ needs.define-matrix.outputs.base_image }}' | jq -r '.[] | .tag'); do
            docker manifest create ghcr.io/${{ env.REPO_OWNER }}/openhands-runtime:${{ env.RELEVANT_SHA }}-${base_tag} \
              ghcr.io/${{ env.REPO_OWNER }}/openhands-runtime:${{ env.RELEVANT_SHA }}-${base_tag}-amd64 \
              ghcr.io/${{ env.REPO_OWNER }}/openhands-runtime:${{ env.RELEVANT_SHA }}-${base_tag}-arm64
            docker manifest push ghcr.io/${{ env.REPO_OWNER }}/openhands-runtime:${{ env.RELEVANT_SHA }}-${base_tag}
          done

  # Simplified testing with multi-platform support
  test_runtime:
    name: Test Runtime (${{ matrix.base_image.tag }}, ${{ matrix.platform }})
    runs-on: ${{ matrix.platform == 'linux/arm64' && 'ubuntu-latest-arm' || 'ubuntu-latest' }}
    needs: [build_runtime_images, define-matrix]
    strategy:
      fail-fast: false
      matrix:
        base_image: ${{ fromJson(needs.define-matrix.outputs.base_image) }}
        platform: ${{ fromJson(needs.define-matrix.outputs.platforms) }}
        run_as: [root, openhands]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set repository owner
        run: |
          echo REPO_OWNER=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]') >> $GITHUB_ENV

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install poetry and dependencies
        run: |
          pipx install poetry
          make install-python-dependencies POETRY_GROUP=main,test,runtime INSTALL_PLAYWRIGHT=0

      - name: Run runtime tests
        run: |
          poetry run pip install pytest-xdist pytest-rerunfailures

          platform_suffix=$(echo ${{ matrix.platform }} | cut -d'/' -f2)
          image_name=ghcr.io/${{ env.REPO_OWNER }}/openhands-runtime:${{ env.RELEVANT_SHA }}-${{ matrix.base_image.tag }}-${platform_suffix}

          TEST_RUNTIME=docker \
          SANDBOX_USER_ID=$(id -u) \
          SANDBOX_RUNTIME_CONTAINER_IMAGE=$image_name \
          TEST_IN_CI=true \
          RUN_AS_OPENHANDS=${{ matrix.run_as == 'openhands' && 'true' || 'false' }} \
          poetry run pytest -n 4 -raRs --reruns 2 --reruns-delay 5 -s ./tests/runtime --ignore=tests/runtime/test_browsergym_envs.py --durations=10

  # Final success check
  all_tests_passed:
    name: All Tests Passed
    if: ${{ !cancelled() && !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
    runs-on: ubuntu-latest
    needs: [test_runtime]
    steps:
      - name: All tests passed
        run: echo "All tests have passed successfully!"

  all_tests_failed:
    name: All Tests Passed
    if: ${{ cancelled() || contains(needs.*.result, 'failure') || contains(needs.*.result, 'cancelled') }}
    runs-on: ubuntu-latest
    needs: [test_runtime]
    steps:
      - name: Some tests failed
        run: |
          echo "Some tests failed or were cancelled"
          exit 1
